// --- GLOBAIS ---
const viewport = document.getElementById('viewport');
const world = document.getElementById('world');
const sidebar = document.getElementById('sidebar');
const svgLayer = document.getElementById('connections-layer');
const contextMenu = document.getElementById('context-menu');
const connectionPicker = document.getElementById('connection-picker');
const pickerList = document.getElementById('picker-list');
const breadcrumbsBar = document.getElementById('breadcrumbs');

// Container para Camadas Especiais (Editores, Players, etc)
const docLayer = document.getElementById('doc-layer'); // Certifique-se que essa DIV existe no HTML

// --- ESTADO ---
const state = { scale: 1, x: 0, y: 0, isPanning: false, panStartX: 0, panStartY: 0, draggedCard: null, mouseStartX: 0, mouseStartY: 0 };

// --- REGISTRO DE PLUGINS (A NOVIDADE) ---
// Aqui guardaremos as aÃ§Ãµes de cada plugin. 
// Ex: { 'text': functionOpenEditor, 'video': functionPlayVideo }
window.pluginActions = {}; 

let currentLayerID = 'root';
let layerStack = []; 
let layerStorage = { 'root': { type: 'canvas', elements: [], connections: [] } };
let currentConnections = []; 
let contextTargetID = null;

// --- API PÃšBLICA (PARA OS PLUGINS USAREM) ---

// 1. FunÃ§Ã£o para o plugin dizer: "Quando clicarem no card tipo X, rode essa funÃ§Ã£o"
window.registerCardBehavior = function(type, onDoubleClick) {
    window.pluginActions[type] = onDoubleClick;
};

// 2. FunÃ§Ã£o para adicionar botÃ£o na sidebar
window.registerPlugin = function(icon, tooltip, action) {
    const btn = document.createElement('button'); 
    btn.className='tool-btn'; 
    btn.innerHTML=icon; 
    btn.title=tooltip;
    btn.onclick=(e)=>{e.stopPropagation(); action();}; 
    sidebar.appendChild(btn);
};

// 3. FunÃ§Ã£o para criar o card (Agora aceita o TIPO)
window.spawnCardAtCenter = function(html, type = 'default') {
    const cx = ((window.innerWidth-60)/2 - state.x)/state.scale; 
    const cy = (window.innerHeight/2 - state.y)/state.scale;
    
    const el = document.createElement('div'); 
    el.className = 'card'; 
    el.id = 'c-' + Date.now() + Math.random().toString(16).slice(2);
    
    // O SEGREDO: Marcamos o card com o tipo do plugin
    el.setAttribute('data-type', type);
    el.setAttribute('data-x', cx); 
    el.setAttribute('data-y', cy); 
    el.style.transform = `translate(${cx}px,${cy}px)`;
    el.innerHTML = html; 
    
    world.appendChild(el); 
    return el;
};

// 4. FunÃ§Ã£o para esconder o canvas e mostrar uma interface de plugin (ex: editor de texto)
window.enablePluginMode = function(elementToShow) {
    viewport.style.display = 'none'; // Esconde o mundo
    elementToShow.style.display = 'block'; // Mostra o plugin (ex: editor)
};

// 5. FunÃ§Ã£o para voltar ao canvas normal
window.disablePluginMode = function(elementToHide) {
    elementToHide.style.display = 'none';
    viewport.style.display = 'block';
    draw(); // Redesenha o mundo
};

// --- CORE: SISTEMA DE DUPLO CLIQUE (O ROTEADOR) ---

viewport.addEventListener('dblclick', (e) => {
    const card = e.target.closest('.card');
    if (!card) return;

    e.stopPropagation(); // Impede zoom ou outros efeitos
    
    // 1. Descobre qual Ã© o tipo desse card
    const type = card.getAttribute('data-type') || 'default';
    
    // 2. Verifica se existe algum plugin registrado para esse tipo
    if (window.pluginActions[type]) {
        // SE TIVER PLUGIN: Manda o plugin resolver!
        window.pluginActions[type](card);
    } else {
        // SE NÃƒO TIVER (Comportamento PadrÃ£o): Tenta entrar como Pasta/Camada
        let title = card.querySelector('h2') ? card.querySelector('h2').innerText : 'Sem Nome';
        // Efeito visual
        card.style.transform += " scale(1.1)";
        setTimeout(() => {
            enterLayer(card.id, title);
        }, 100);
    }
});

// --- SISTEMA DE CAMADAS (LAYERS) ---

function saveCurrentLayerState() {
    if (layerStorage[currentLayerID].type === 'canvas') {
        const elements = Array.from(world.children).filter(el => el.classList.contains('card'));
        layerStorage[currentLayerID].elements = elements;
        layerStorage[currentLayerID].connections = [...currentConnections];
        layerStorage[currentLayerID].viewState = { x: state.x, y: state.y, scale: state.scale };
        layerStorage[currentLayerID].title = currentLayerID === 'root' ? 'Brain' : 'Pasta';
    }
}

function enterLayer(cardID, cardTitle) {
    let parentTitle = 'Brain';
    if (currentLayerID !== 'root') {
        const lastCrumb = document.querySelector('.crumb.active');
        parentTitle = lastCrumb ? lastCrumb.innerText : 'Voltar';
    }

    saveCurrentLayerState();
    layerStack.push({ id: currentLayerID, title: parentTitle, type: 'canvas' });

    currentLayerID = cardID;
    
    if (!layerStorage[currentLayerID]) {
        layerStorage[currentLayerID] = { type: 'canvas', elements: [], connections: [], viewState: { x: 0, y: 0, scale: 1 } };
    }

    updateBreadcrumbs(cardTitle);
    renderLayer(currentLayerID);
}

function goToLayer(layerID) {
    if (layerID === currentLayerID) return;
    saveCurrentLayerState();

    const index = layerStack.findIndex(l => l.id === layerID);
    if (index !== -1) {
        layerStack = layerStack.slice(0, index);
    } else if (layerID === 'root') {
        layerStack = [];
    }

    currentLayerID = layerID;
    renderLayer(currentLayerID);
    updateBreadcrumbs(); 
}
window.goToLayer = goToLayer; // ExpÃµe para o HTML

function renderLayer(layerID) {
    // Garante que estamos vendo o canvas, nÃ£o um plugin
    viewport.style.display = 'block';
    if(docLayer) docLayer.classList.remove('active'); // Garante que editores fechem
    
    const layerData = layerStorage[layerID];

    // Limpa tela
    const cards = document.querySelectorAll('.card');
    cards.forEach(c => c.remove());
    svgLayer.innerHTML = ''; 

    currentConnections = layerData.connections || [];
    layerData.elements.forEach(el => world.appendChild(el));
    
    currentConnections.forEach(conn => {
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.classList.add('connector-line');
        conn.line = path; 
        svgLayer.appendChild(path);
        const el1 = document.getElementById(conn.from);
        const el2 = document.getElementById(conn.to);
        if(el1 && el2) drawSVGPath(path, el1, el2);
    });

    if (layerData.viewState) {
        state.x = layerData.viewState.x; state.y = layerData.viewState.y; state.scale = layerData.viewState.scale;
    } else {
        state.x = 0; state.y = 0; state.scale = 1;
    }
    draw();
}

function updateBreadcrumbs(activeTitleOverride) {
    let html = ``;
    if (layerStack.length === 0) {
        html += `<span class="crumb active">Brain</span>`;
    } else {
        layerStack.forEach((layer) => {
            html += `<span class="crumb" onclick="goToLayer('${layer.id}')">${layer.title}</span>`;
            html += `<span class="crumb-separator">/</span>`;
        });
        html += `<span class="crumb active">${activeTitleOverride || "Atual"}</span>`;
    }
    breadcrumbsBar.innerHTML = html;
}


// --- CORE: MOVIMENTO E ZOOM (Igual ao anterior) ---
function draw() {
    world.style.transform = `translate(${state.x}px, ${state.y}px) scale(${state.scale})`;
    viewport.style.backgroundPosition = `${state.x}px ${state.y}px`;
    viewport.style.backgroundSize = `${40 * state.scale}px ${40 * state.scale}px`;
    document.getElementById('zoom-level').innerText = Math.round(state.scale * 100) + '%';
}

viewport.addEventListener('mousedown', (e) => {
    if (e.button === 2) return; 
    hideContextMenu();
    if (e.button === 1) { e.preventDefault(); startPan(e); return; }
    if (e.button === 0) {
        const card = e.target.closest('.card');
        if (e.target.isContentEditable) return; 
        if (card) startDragCard(e, card); else startPan(e);
    }
});

window.addEventListener('mousemove', (e) => {
    if (state.isPanning) {
        e.preventDefault(); state.x = e.clientX - state.panStartX; state.y = e.clientY - state.panStartY; draw();
    }
    if (state.draggedCard) {
        e.preventDefault();
        const dX = e.clientX - state.mouseStartX; const dY = e.clientY - state.mouseStartY;
        const nX = state.cardStartX + (dX / state.scale); const nY = state.cardStartY + (dY / state.scale);
        state.draggedCard.style.transform = `translate(${nX}px, ${nY}px)`;
        state.draggedCard.setAttribute('data-x', nX); state.draggedCard.setAttribute('data-y', nY);
        updateLines(state.draggedCard.id);
    }
});

window.addEventListener('mouseup', () => {
    state.isPanning = false;
    if (state.draggedCard) { state.draggedCard.classList.remove('dragging'); state.draggedCard = null; }
    viewport.style.cursor = 'default';
});

viewport.addEventListener('wheel', (e) => {
    e.preventDefault();
    const d = -Math.sign(e.deltaY); const s = Math.min(Math.max(0.1, state.scale + (d * 0.1)), 5);
    const mX = e.clientX; const mY = e.clientY; 
    state.x -= (mX - state.x) * (s / state.scale - 1); state.y -= (mY - state.y) * (s / state.scale - 1);
    state.scale = s; draw();
}, { passive: false });

function startPan(e) { state.isPanning = true; state.panStartX = e.clientX - state.x; state.panStartY = e.clientY - state.y; viewport.style.cursor = 'grabbing'; }
function startDragCard(e, card) { state.draggedCard = card; state.mouseStartX = e.clientX; state.mouseStartY = e.clientY; state.cardStartX = parseFloat(card.getAttribute('data-x')); state.cardStartY = parseFloat(card.getAttribute('data-y')); card.classList.add('dragging'); e.stopPropagation(); }

// --- CONEXÃ•ES E MENUS ---
function updateLines(movedCardID) {
    currentConnections.forEach(conn => {
        if (conn.from === movedCardID || conn.to === movedCardID) {
            const el1 = document.getElementById(conn.from); const el2 = document.getElementById(conn.to);
            if (el1 && el2) drawSVGPath(conn.line, el1, el2);
        }
    });
}
function drawSVGPath(path, el1, el2) {
    const off = 50000;
    const x1 = parseFloat(el1.getAttribute('data-x')) + el1.offsetWidth/2; const y1 = parseFloat(el1.getAttribute('data-y')) + el1.offsetHeight/2;
    const x2 = parseFloat(el2.getAttribute('data-x')) + el2.offsetWidth/2; const y2 = parseFloat(el2.getAttribute('data-y')) + el2.offsetHeight/2;
    const sx = x1+off; const sy = y1+off; const ex = x2+off; const ey = y2+off; const dist = Math.abs(ex-sx)*0.5;
    path.setAttribute('d', `M ${sx} ${sy} C ${sx+dist} ${sy}, ${ex-dist} ${ey}, ${ex} ${ey}`);
}

window.addEventListener('contextmenu', (e) => {
    e.preventDefault(); const card = e.target.closest('.card');
    if (card) { contextTargetID = card.id; showContextMenu(e.clientX, e.clientY, true); } else hideContextMenu();
});

function showContextMenu(x, y, isCard) {
    contextMenu.style.display = 'block'; contextMenu.style.left = x + 'px'; contextMenu.style.top = y + 'px'; contextMenu.innerHTML = ''; 
    if (isCard) {
        const btnConn = document.createElement('div'); btnConn.className = 'menu-item'; btnConn.innerText = 'ðŸ”— Conectar'; btnConn.onclick = window.openConnectionPicker; contextMenu.appendChild(btnConn);
        const btnDel = document.createElement('div'); btnDel.className = 'menu-item'; btnDel.innerText = 'ðŸ—‘ï¸ Excluir'; btnDel.style.color='#ff5555'; 
        btnDel.onclick = () => { 
            const card = document.getElementById(contextTargetID); 
            if(card) {
                currentConnections.forEach(conn => { if (conn.from === contextTargetID || conn.to === contextTargetID) conn.line.remove(); });
                card.remove(); 
            }
            currentConnections = currentConnections.filter(c => c.from!==contextTargetID && c.to!==contextTargetID); 
            hideContextMenu();
        }; 
        contextMenu.appendChild(btnDel);
    }
}
function hideContextMenu() { contextMenu.style.display = 'none'; }
window.openConnectionPicker = function() { hideContextMenu(); connectionPicker.style.display = 'block'; pickerList.innerHTML = ''; document.querySelectorAll('.card').forEach(c => { if(c.id!==contextTargetID){ const d = document.createElement('div'); d.className='picker-option'; d.innerText=c.querySelector('h2').innerText; d.onclick=()=>{ createConn(c.id); }; pickerList.appendChild(d); } }); };
window.closePicker = function() { connectionPicker.style.display = 'none'; };
function createConn(toID) { 
    const path = document.createElementNS('http://www.w3.org/2000/svg','path'); path.className='connector-line'; svgLayer.appendChild(path);
    currentConnections.push({from:contextTargetID, to:toID, line:path}); 
    drawSVGPath(path, document.getElementById(contextTargetID), document.getElementById(toID)); window.closePicker(); 
}

// Inicializa
draw();
